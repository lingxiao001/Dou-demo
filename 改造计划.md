# 混合架构改造计划：集成 Android 原生 ViewPager (Add-to-App)

本文档旨在指导如何将当前的 `douyin_demo` Flutter 项目改造为混合架构项目。基于用户提供的深度考量，我们将采用 **Add-to-App** 模式，以 Android 原生为主导，Flutter 作为业务模块嵌入。

## 1. 核心设计理念与策略

根据混合架构的最佳实践，我们在本计划中明确以下核心策略：

### 1.1 引擎管理 (Engine Strategy)
*   **策略**：**单引擎预热模式 (Single Cached Engine)**。
*   **理由**：Flutter 引擎启动成本高，内存占用大。多引擎模式会导致内存爆炸。
*   **实现**：
    *   在 `Application.onCreate` 中初始化 `FlutterEngine`。
    *   使用 `FlutterEngineCache` 缓存该引擎（ID: `main_engine`）。
    *   所有 Flutter 页面（通过 `FlutterFragment`）复用该引擎。
    *   *注意*：复用引擎意味着 Flutter 端是单例的，页面切换时状态会保留。如果需要在不同 Fragment 显示不同 Flutter 页面，需要在切换时通过 Channel 通知 Flutter 路由栈变化，或者接受 Flutter 页面在后台被“挂起”的状态。由于我们主要用 Flutter 做视频流（视频内流tiktop video page），这种单例模式非常契合。

### 1.2 导航栈管理 (Navigation Stack)
*   **策略**：**原生主导 (Native Driven)**。
*   **实现**：
    *   最外层是 Android 的 `MainActivity` + `ViewPager2`。
    *   页面作为 `Fragment` 存在于原生栈中。
    *   Flutter 页面只是其中一个 `Fragment` (`FlutterFragment`)。
    *   **页面粒度**：遵循“以页面为维度进行混合”的原则，不进行细粒度的 View 混排。

### 1.3 通信机制 (Platform Channels)
*   **策略**：**Pigeon (类型安全)** + **MethodChannel**。
*   **实现**：
    *   使用 `MethodChannel` 处理简单的指令（如：`pauseVideo`, `resumeVideo` 当 ViewPager 滑动时）。
    *   后续引入 `Pigeon` 规范化数据传递（如用户信息同步）。

### 1.4 业务模块划分
*   **Flutter 部分**：保留现有的 `ViewerScreen` (视频流)，因为其视觉效果已达标且重写成本高。
*   **Native 部分**：负责 App 骨架 (`MainActivity`, `ViewPager2`)，以及未来可能拓展的地图或极高性能要求的模块。

---

## 2. 详细实施步骤

### 第一阶段：Android 工程环境准备 (Environment)

目前 `android` 目录是 Flutter 自动生成的宿主工程，需升级为标准原生工程配置。

1.  **修改 `build.gradle.kts`**：
    *   引入 `ViewPager2`, `Material Design`, `ConstraintLayout`。
    *   调整 `compileSdk` 等版本配置。

2.  **资源准备**：
    *   创建原生布局文件 `activity_main.xml`。

### 第二阶段：引擎预热与应用入口 (Engine Warm-up)

1.  **创建 `MyApplication`**：
    *   继承 `FlutterApplication`。
    *   在 `onCreate` 中初始化并缓存 `FlutterEngine`。
    *   配置 `DartEntrypoint`。

2.  **配置 `AndroidManifest.xml`**：
    *   注册 `MyApplication`。
    *   调整 `MainActivity` 的主题和启动模式。

### 第三阶段：改造 MainActivity与导航 (Navigation)

1.  **重写 `MainActivity`**：
    *   改为继承 `FragmentActivity`。
    *   初始化 `ViewPager2`。

2.  **实现 `FragmentStateAdapter`**：
    *   **Page 0**: `FlutterFragment` (使用缓存的 `main_engine`) -> 展示 Flutter 视频流。
    *   **Page 1**: `NativeFragment` (示例) -> 展示原生页面（如个人中心或设置）。

3.  **解决手势冲突**：
    *   `ViewPager2` (横向) vs Flutter `PageView` (纵向)。
    *   通常 `ViewPager2` 处理得很好，但需测试。如有冲突，需在 Native 层拦截触摸事件。

### 第四阶段：Flutter 端适配 (Adaptation)

1.  **生命周期响应**：
    *   监听 Android 原生页面的生命周期（`onResume`, `onPause`）。
    *   当 ViewPager 滑动到其他页面时，Flutter 视频应自动暂停。

---

## 3. 代码改造示例

### 3.1 添加依赖 (android/app/build.gradle.kts)

```kotlin
dependencies {
    implementation("androidx.viewpager2:viewpager2:1.0.0")
    implementation("com.google.android.material:material:1.9.0")
    implementation("androidx.constraintlayout:constraintlayout:2.1.4")
    // ...
}
```

### 3.2 引擎预热 (MyApplication.kt)

```kotlin
class MyApplication : FlutterApplication() {
    override fun onCreate() {
        super.onCreate()
        val flutterEngine = FlutterEngine(this)
        flutterEngine.dartExecutor.executeDartEntrypoint(
            DartExecutor.DartEntrypoint.createDefault()
        )
        FlutterEngineCache.getInstance().put("main_engine", flutterEngine)
    }
}
```

### 3.3 混合栈适配器 (MainActivity.kt)

```kotlin
class MainAdapter(fa: FragmentActivity) : FragmentStateAdapter(fa) {
    override fun getItemCount(): Int = 2

    override fun createFragment(position: Int): Fragment {
        return when (position) {
            0 -> FlutterFragment.withCachedEngine("main_engine").build() // Flutter 视频流
            else -> NativeProfileFragment() // 原生个人中心
        }
    }
}
```
